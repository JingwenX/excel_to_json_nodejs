// Generated by CoffeeScript 1.10.0
(function() {
  var BOOLTEXT, BOOLVALS, _DEFAULT_OPTIONS, _validateOptions, assign, convert, convertValue, convertValueList, excel, fs, isArray, parseKeyName, path, processFile, transpose, write,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  path = require('path');

  excel = require('excel');

  BOOLTEXT = ['true', 'false'];

  BOOLVALS = {
    'true': true,
    'false': false
  };

  isArray = function(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  };

  parseKeyName = function(key) {
    var index;
    index = key.match(/\[(\d+)\]$/);
    switch (false) {
      case !index:
        return [true, key.split('[')[0], Number(index[1])];
      case key.slice(-2) !== '[]':
        return [true, key.slice(0, -2), void 0];
      default:
        return [false, key, void 0];
    }
  };

  convertValueList = function(list) {
    var item, j, len, results;
    results = [];
    for (j = 0, len = list.length; j < len; j++) {
      item = list[j];
      results.push(convertValue(item));
    }
    return results;
  };

  convertValue = function(value) {
    var testVal;
    if (value.length === 0 || !/\S/.test(value)) {
      return value;
    } else if (isFinite(value)) {
      return Number(value);
    } else {
      testVal = value.toLowerCase();
      if (indexOf.call(BOOLTEXT, testVal) >= 0) {
        return BOOLVALS[testVal];
      } else {
        return value;
      }
    }
  };

  assign = function(obj, key, value, options) {
    var i, index, j, keyIsList, keyName, ref, ref1, ref2;
    if (typeof key !== 'object') {
      key = key.split('.');
    }
    ref = parseKeyName(key.shift()), keyIsList = ref[0], keyName = ref[1], index = ref[2];
    if (key.length) {
      if (keyIsList) {
        if (isArray(obj[keyName])) {
          if (!obj[keyName][index]) {
            for (i = j = ref1 = obj[keyName].length, ref2 = index; ref1 <= ref2 ? j <= ref2 : j >= ref2; i = ref1 <= ref2 ? ++j : --j) {
              obj[keyName].push({});
            }
          }
        } else {
          obj[keyName] = (function() {
            var k, ref3, results;
            results = [];
            for (i = k = 0, ref3 = index; 0 <= ref3 ? k <= ref3 : k >= ref3; i = 0 <= ref3 ? ++k : --k) {
              results.push({});
            }
            return results;
          })();
        }
        return assign(obj[keyName][index], key, value, options);
      } else {
        if (obj[keyName] == null) {
          obj[keyName] = {};
        }
        return assign(obj[keyName], key, value, options);
      }
    } else {
      if (keyIsList && (index != null)) {
        console.error("WARNING: Unexpected key path terminal containing an indexed list for <" + keyName + ">");
        console.error("WARNING: Indexed arrays indicate a list of objects and should not be the last element in a key path");
        console.error("WARNING: The last element of a key path should be a key name or flat array. E.g. alias, aliases[]");
      }
      if (keyIsList && (index == null)) {
        if (!(options.omitEmptyFields && value === '')) {
          return obj[keyName] = convertValueList(value.split(';'));
        }
      } else {
        if (!(options.omitEmptyFields && value === '')) {
          return obj[keyName] = convertValue(value);
        }
      }
    }
  };

  transpose = function(matrix) {
    var i, j, ref, results, t;
    results = [];
    for (i = j = 0, ref = matrix[0].length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      results.push((function() {
        var k, len, results1;
        results1 = [];
        for (k = 0, len = matrix.length; k < len; k++) {
          t = matrix[k];
          results1.push(t[i]);
        }
        return results1;
      })());
    }
    return results;
  };

  convert = function(data, options) {
    var index, item, j, k, keys, len, len1, result, row, rows, value;
    if (options.isColOriented) {
      data = transpose(data);
    }
    keys = data[0];
    rows = data.slice(1);
    result = [];
    for (j = 0, len = rows.length; j < len; j++) {
      row = rows[j];
      item = {};
      for (index = k = 0, len1 = row.length; k < len1; index = ++k) {
        value = row[index];
        assign(item, keys[index], value, options);
      }
      result.push(item);
    }
    return result;
  };

  write = function(data, dst, callback) {
    var dir;
    dir = path.dirname(dst);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir);
    }
    return fs.writeFile(dst, JSON.stringify(data, null, 2), function(err) {
      if (err) {
        return callback("Error writing file " + dst + ": " + err);
      } else {
        return callback(void 0);
      }
    });
  };

  _DEFAULT_OPTIONS = {
    sheet: '1',
    isColOriented: false,
    omitEmptyFields: false
  };

  _validateOptions = function(options) {
    if (!options) {
      options = _DEFAULT_OPTIONS;
    } else {
      if (!options.hasOwnProperty('sheet')) {
        options.sheet = '1';
      } else {
        if (!isNaN(parseFloat(options.sheet)) && isFinite(options.sheet)) {
          if (options.sheet < 1) {
            options.sheet = '1';
          } else {
            options.sheet = '' + options.sheet;
          }
        } else {
          options.sheet = '1';
        }
      }
      if (!options.hasOwnProperty('isColOriented')) {
        options.isColOriented = false;
      }
      if (!options.hasOwnProperty('omitEmptyFields')) {
        options.omitEmptyFields = false;
      }
    }
    return options;
  };

  processFile = function(src, dst, options, callback) {
    if (options == null) {
      options = _DEFAULT_OPTIONS;
    }
    if (callback == null) {
      callback = void 0;
    }
    options = _validateOptions(options);
    if (!callback) {
      callback = function(err, data) {};
    }
    if (!fs.existsSync(src)) {
      return callback("Cannot find src file " + src);
    } else {
      return excel(src, options.sheet, function(err, data) {
        var result;
        if (err) {
          return callback("Error reading " + src + ": " + err);
        } else {
          result = convert(data, options);
          if (dst) {
            return write(result, dst, function(err) {
              if (err) {
                return callback(err);
              } else {
                return callback(void 0, result);
              }
            });
          } else {
            return callback(void 0, result);
          }
        }
      });
    }
  };

  exports.processFile = processFile;

  exports.assign = assign;

  exports.convert = convert;

  exports.convertValue = convertValue;

  exports.parseKeyName = parseKeyName;

  exports._validateOptions = _validateOptions;

  exports.transpose = transpose;

}).call(this);
